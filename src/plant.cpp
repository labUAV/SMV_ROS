/**
 * \brief Kinematic model of a ground robot.
 * 
 * This ROS1 node simulates the ground robot kinematics. It receives
 * a velocity command in rad/s for the left and right wheel and computes
 * the robot pose.
 * 
 * @author Davide Carminati
 * Copyright (C) 2024 Davide Carminati
 * 
 * This program is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, either version 3 of the License, or 
 * (at your option) any later version. 
 * 
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details. 
 * 
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see <https://www.gnu.org/licenses/>. 
*/

#include "ros/ros.h"
#include "nav_msgs/Odometry.h"
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <mutex>

#include "planner_controller/APFTrajectory.h"
#include "planner_controller/WheelCommand.h"

#include "robot_plant.h"
#include "rtwtypes.h"

using namespace Eigen;

class Plant
{
private:
    ros::NodeHandle nh;
    ros::Rate loop_rate;
    ros::Publisher odometry_publisher;
    ros::Subscriber command_subscriber;
    ModelClass robot_plant_simulator;       // The ModelClass class is generated by Simulink
    nav_msgs::Odometry odometry_msg;
    std::mutex pub_mutex;
public:
    Plant(ros::NodeHandle* nh, double freq);
    ~Plant();
    void simulatePlant(const planner_controller::WheelCommand::ConstPtr &command);
};

/**
 * \brief Constructor.
 * 
 * \param nh ROS NodeHandle. Needed to use ROS features
 * \param freq Frequency in Hz at which this node runs
 * 
 * \details This method automatically runs when an instance of this class is created.
 * It initializes the subscriber and the publisher. This node continuously publishes 
 * the robot states at the given frequency. When it receives a new command, the robot
 * states are updated in the callback.
 * 
*/
Plant::Plant(ros::NodeHandle* nh, double freq) : nh(*nh), loop_rate(freq)
{
    command_subscriber = nh->subscribe("/command", 1, &Plant::simulatePlant, this);
    odometry_publisher = nh->advertise<nav_msgs::Odometry>("/estimated_state", 10);
    robot_plant_simulator.initialize();

    ROS_INFO("Starting robot model...");
    const std::lock_guard<std::mutex> lock(pub_mutex);
    odometry_msg.pose.pose.orientation.w = 1.0;
    lock.~lock_guard();
    while (ros::ok())
    {
        odometry_msg.header.stamp = ros::Time::now();
        odometry_publisher.publish(odometry_msg);
        ros::spinOnce();                                // Be ready to execute simulatePlant() if a message is received
        loop_rate.sleep();                              // Sleep to achieve the given frequency
    }

}

Plant::~Plant()
{
}

/**
 * \brief Update the robot states by stepping the model
 * 
 * \param command Pointer to received message
 * 
 * \details This callback is executed every time this nodes receives a new message.
 * This method simply assign the command velocities to the input struct, then it steps
 * the model and finally it reads the updated states from the output struct.
 * 
 * The step() method is generated by Simulink.
 * 
*/
void Plant::simulatePlant(const planner_controller::WheelCommand::ConstPtr &command)
{
    ModelClass::ExtU_robot_plant_T input_signals;
    ModelClass::ExtY_robot_plant_T output_signals;
    input_signals.omega_l = command->omega_l;
    input_signals.omega_r = command->omega_r;
    robot_plant_simulator.setExternalInputs(&input_signals);
    robot_plant_simulator.step();
    output_signals = robot_plant_simulator.getExternalOutputs();

    // Update odometry
    const std::lock_guard<std::mutex> lock(pub_mutex);
    odometry_msg.pose.pose.position.x       = output_signals.x;
    odometry_msg.pose.pose.position.y       = output_signals.y;
    odometry_msg.pose.pose.orientation.w    = output_signals.q[0];
    odometry_msg.pose.pose.orientation.z    = output_signals.q[3];
    odometry_msg.twist.twist.linear.x       = output_signals.Vx;
    odometry_msg.twist.twist.linear.y       = output_signals.Vy;
    odometry_msg.twist.twist.angular.z      = output_signals.psi_dot;
    // It is crucial to assign a timestamp to the message!
    odometry_msg.header.stamp               = ros::Time::now();

}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "plant");
    ros::NodeHandle n;
    double node_frequency = 100; // Hz
    Plant plant(&n, node_frequency);

    ros::spin();
    
    return 0;
}
